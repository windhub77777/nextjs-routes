import { readdirSync, statSync } from "fs";
import { join, parse } from "path";

const NEXTJS_NON_ROUTABLE_PREFIX = "_";
export const NEXTJS_PAGES_DIRECTORY_NAME = "pages";
const DYNAMIC_SEGMENT_RE = /\[(.*?)\]/g;

export function findFiles(entry: string): string[] {
  return readdirSync(entry).flatMap((file) => {
    const filepath = join(entry, file);
    if (
      statSync(filepath).isDirectory() &&
      !filepath.includes("node_modules")
    ) {
      return findFiles(filepath);
    }
    return filepath;
  });
}

function humanize(input: string): string {
  return input
    .replace(/\[.*?]/g, "")
    .replace(/\]/g, "")
    .replace("...", "")
    .split(/\/|-|_/)
    .filter(Boolean)
    .map((x) => x[0].toUpperCase() + x.slice(1))
    .join("");
}

type QueryType = "dynamic" | "catch-all" | "optional-catch-all";

interface Route {
  pathname: string;
  query: Record<string, QueryType>;
}

export function nextRoutes(files: string[]): Route[] {
  const filenames = files
    .map((file) =>
      file.replace(NEXTJS_PAGES_DIRECTORY_NAME, "").replace(parse(file).ext, "")
    )
    .filter((file) => !parse(file).name.startsWith(NEXTJS_NON_ROUTABLE_PREFIX));

  return filenames.map((filename) => {
    const segments = filename.match(DYNAMIC_SEGMENT_RE) ?? [];
    const query = segments.reduce<Route["query"]>((acc, cur) => {
      const param = cur
        .replace(/\[/g, "")
        .replace(/\]/g, "")
        .replace("...", "");
      let queryType: QueryType = "dynamic";
      if (cur.startsWith("[[")) {
        queryType = "optional-catch-all";
      } else if (cur.startsWith("[...")) {
        queryType = "catch-all";
      }
      acc[param] = queryType;
      return acc;
    }, {});

    return {
      pathname: filename,
      query,
    };
  });
}

function getQueryInterface(query: Route["query"]): string {
  let res = "";
  Object.entries(query).forEach(([key, value]) => {
    res += key;
    switch (value) {
      case "dynamic": {
        res += ": string";
        break;
      }
      case "catch-all": {
        res += ": string[]";
        break;
      }
      case "optional-catch-all": {
        res += "?: string[]";
        break;
      }
      default: {
        const _exhaust: never = value;
        return _exhaust;
      }
    }
    res += "; ";
  });

  if (res) {
    return `{ ${res}}`;
  }
  return res;
}

function getRouteHelperInterface(route: Route): string {
  const query = getQueryInterface(route.query);
  let generic = "";
  if (query) {
    generic = `NextUrl<'${route.pathname}', ${query}>`;
  } else {
    generic = `NextUrl<'${route.pathname}'>`;
  }

  const optionalArgs = !query;

  return `${humanize(route.pathname)}: function<Url extends ${generic}>(opts${
    optionalArgs ? "?" : ""
  }: Omit<Url, 'pathname'>): Url`;
}

export function generate(routes: Route[]): string {
  let res = "";
  res += `\
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.'
import type { NextUrl } from 'nextjs-routes';

declare module 'nextjs-routes' {
  interface NextjsRoutes {
    generatedRoutes: Routes;
  }
}

export type Routes =
  | ${routes
    .map((route) => {
      const query = getQueryInterface(route.query);
      if (query) {
        return `NextUrl<'${route.pathname}', ${query}>`;
      } else {
        return `NextUrl<'${route.pathname}'>`;
      }
    })
    .join("\n  | ")}

export const Route = {
  ${routes
    .map(
      (route) =>
        `${getRouteHelperInterface(route)} {
    return { pathname: '${route.pathname}', ...opts };
  }`
    )
    .join(",\n  ")}
} as const;
`;

  return res;
}
